local Library=
loadstring(game:HttpGet("https://raw.githubusercontent.com/tbao143/Library-ui/refs/heads/main/Redzhubui"))()



local Window = Library:MakeWindow({
    Title = "Matrix Hub v4.4: BROOKHAVEN RP üè°",
    SubTitle = "By : Matrix Community",
    SaveFolder = "MATRIXHUB Folder"
})

Window:AddMinimizeButton({
    Button = { Image = "rbxassetid://85219327131493", BackgroundTransparency = 0 }, -- Coloque um ID v√°lido
    Corner = { CornerRadius = UDim.new(0, 10) }
})

local Tab1 = Window:MakeTab({"Home", "rbxassetid://138700382840270"})

local Section = Tab1:AddSection("Cr√©ditos: Matrix COMMUNITY")

Tab1:AddParagraph({"üîß Interface Reformulada: Nova estrutura visual com foco em efici√™ncia e organiza√ß√£o."})
Tab1:AddParagraph({"‚öôÔ∏è HUB ATUALIZADA COM NOVAS FUNCIONALIDADES INOVADORAS."})
Tab1:AddParagraph({"‚úÖ Estabilidade Aprimorada: Menor chance de falhas e resposta mais r√°pida do sistema."})

local playerName = game.Players.LocalPlayer.Name
Tab1:AddParagraph({"Ol√°, " .. playerName .. "! ‚òÑ Seja bem-vindo ao MATRIX HUBüé©. Aproveite com responsabilidade e Cuidado."})

local Tab2 = Window:MakeTab({"Troll", "rbxassetid://10734934585"})

local Section = Tab2:AddSection({"Troll v4 By Not legitty"})

local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")
local LocalPlayer = Players.LocalPlayer
local CurrentCamera = workspace.CurrentCamera
local RunService = game:GetService("RunService")

local viewEnabled = false
local currentTarget = nil
local characterAddedConn = nil
local playerNames = {}

-- Fun√ß√£o para atualizar a lista de jogadores
local function updateDropdown()
    playerNames = {}
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer then
            table.insert(playerNames, player.Name)
        end
    end
    if Dropdown then
        Dropdown:Set(playerNames)
    end
end

-- Fun√ß√£o para tratar a adi√ß√£o de novos jogadores
local function onPlayerAdded(player)
    if player ~= LocalPlayer then
        table.insert(playerNames, player.Name)
        if Dropdown then
            Dropdown:Set(playerNames)
        end
    end
end

-- Fun√ß√£o para tratar a remo√ß√£o de jogadores
local function onPlayerRemoving(player)
    for i, name in ipairs(playerNames) do
        if name == player.Name then
            table.remove(playerNames, i)
            break
        end
    end
    if Dropdown then
        Dropdown:Set(playerNames)
    end

    if currentTarget == player then
        stopViewing()
    end
end

-- Atualizando dropdown com lista de jogadores ao iniciar
Players.PlayerAdded:Connect(onPlayerAdded)
Players.PlayerRemoving:Connect(onPlayerRemoving)
task.delay(1, updateDropdown)

-- Fun√ß√£o para resetar a c√¢mera do jogador local
local function resetCamera()
    if LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait() then
        CurrentCamera.CameraSubject = LocalPlayer.Character
    end
end

-- Fun√ß√£o para fazer a transi√ß√£o da c√¢mera para o alvo
local function tweenToTargetPart(part)
    local tweenInfo = TweenInfo.new(1, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
    local targetCFrame = part.CFrame + part.CFrame.LookVector * -10 + Vector3.new(0, 5, 0)
    local goal = {CFrame = CFrame.new(targetCFrame.Position, part.Position)}
    local tween = TweenService:Create(CurrentCamera, tweenInfo, goal)
    tween:Play()
end

-- Fun√ß√£o para configurar a visualiza√ß√£o do alvo
function setViewTarget(targetName)
    local targetPlayer = Players:FindFirstChild(targetName)
    if not targetPlayer then
        warn("[VIEW] Jogador n√£o encontrado: " .. targetName)
        return
    end

    currentTarget = targetPlayer

    -- Desconectar qualquer conex√£o anterior
    if characterAddedConn then
        characterAddedConn:Disconnect()
    end

    characterAddedConn = targetPlayer.CharacterAdded:Connect(function(char)
        task.wait(0.1)
        if viewEnabled and currentTarget == targetPlayer then
            local hrp = char:FindFirstChild("HumanoidRootPart")
            if hrp then
                tweenToTargetPart(hrp)
            end
            pcall(function()
                CurrentCamera.CameraSubject = char
            end)
        end
    end)

    -- Verificar o personagem j√° existente
    if targetPlayer.Character then
        local hrp = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
        if hrp then
            tweenToTargetPart(hrp)
        end
        pcall(function()
            CurrentCamera.CameraSubject = targetPlayer.Character
        end)
    end
end

-- Fun√ß√£o para parar a visualiza√ß√£o
function stopViewing()
    viewEnabled = false
    currentTarget = nil
    if characterAddedConn then
        characterAddedConn:Disconnect()
        characterAddedConn = nil
    end
    resetCamera()
end

-- Render loop para atualizar a visualiza√ß√£o
RunService.RenderStepped:Connect(function()
    if viewEnabled and currentTarget then
        if not currentTarget:IsDescendantOf(game) then
            stopViewing()
            return
        end
        if currentTarget.Character and CurrentCamera.CameraSubject ~= currentTarget.Character then
            pcall(function()
                CurrentCamera.CameraSubject = currentTarget.Character
            end)
        end
    end
end)

-- Adicionando o Dropdown para sele√ß√£o de jogador
Dropdown = Tab2:AddDropdown({
    Name = "Selecione o O Player Para view,fling,etc.",
    Options = playerNames,
    Default = {},
    MultiSelect = false,
    Callback = function(Value)
        if typeof(Value) == "string" and Players:FindFirstChild(Value) then
            getgenv().Target = Value
            if viewEnabled then
                setViewTarget(Value)
            end
        end
    end
})

-- Toggle para ativar/desativar a visualiza√ß√£o
Tab2:AddToggle({
    Name = "View",
    Default = false,
    Callback = function(state)
        viewEnabled = state
        if state and getgenv().Target then
            setViewTarget(getgenv().Target)
        else
            stopViewing()
        end
    end
})

-- Atualizando o Dropdown quando um jogador entra ou sai
Players.PlayerAdded:Connect(onPlayerAdded)
Players.PlayerRemoving:Connect(onPlayerRemoving)
task.delay(1, updateDropdown)

local TweenService = game:GetService("TweenService")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

Tab2:AddButton({
	Name = "Goto",
	Callback = function()
		local success, err = pcall(function()
			local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
			local hrp = character:FindFirstChild("HumanoidRootPart")

			if not hrp then return end

			local targetName = getgenv().Target
			if not targetName then
				warn("[GOTO] Nenhum alvo definido.")
				return
			end

			local targetPlayer = Players:FindFirstChild(targetName)
			if not targetPlayer or not targetPlayer.Character then
				warn("[GOTO] Alvo inv√°lido ou n√£o encontrado.")
				return
			end

			local targetHRP = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
			if not targetHRP then
				warn("[GOTO] Alvo sem HumanoidRootPart.")
				return
			end

			-- Tween suave de teleporte
			local goal = {CFrame = targetHRP.CFrame + Vector3.new(0, 5, 0)}
			local tween = TweenService:Create(hrp, TweenInfo.new(0.6, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), goal)
			tween:Play()
		end)

		if not success then
			warn("[GOTO] Erro ao tentar teleportar:", err)
		end
	end
})

local Section = Tab2:AddSection({"<Combate Com Bola‚öΩÔ∏è-"})

-- Servi√ßos
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

-- Jogador local e caminho da bola
local localPlayer = Players.LocalPlayer
local BALL_PATH = "WorkspaceCom/001_SoccerBalls/Soccer" .. localPlayer.Name

-- Vari√°veis globais
getgenv().Target = nil
local ball, connection

-- Remove qualquer for√ßa existente na bola
local function clearForces(targetBall)
	for _, obj in ipairs(targetBall:GetChildren()) do
		if obj:IsA("BodyForce") or obj:IsA("BodyVelocity") or obj:IsA("BodyPosition") then
			obj:Destroy()
		end
	end
end

-- Ignora colis√£o entre a bola e o personagem
local function ignorePlayerCollision(targetBall, targetCharacter)
	for _, part in ipairs(targetCharacter:GetDescendants()) do
		if part:IsA("BasePart") then
			local constraint = Instance.new("NoCollisionConstraint")
			constraint.Part0 = targetBall
			constraint.Part1 = part
			constraint.Parent = targetBall
		end
	end
end

-- Configura a bola para seguir o alvo e causar fling com BodyPosition pr√≥ximo
function setupBall()
	local targetName = getgenv().Target
	if not targetName then
		warn("Nenhum jogador selecionado.")
		return
	end

	local targetPlayer = Players:FindFirstChild(targetName)
	if not targetPlayer then
		warn("Jogador alvo n√£o encontrado.")
		return
	end

	local character = targetPlayer.Character or targetPlayer.CharacterAdded:Wait()
	local torso = character:WaitForChild("UpperTorso", 5) or character:WaitForChild("Torso", 5)

	local success, foundBall = pcall(function()
		local obj = workspace
		for _, part in ipairs(BALL_PATH:split("/")) do
			obj = obj:WaitForChild(part, 5)
		end
		return obj
	end)

	if not success or not foundBall then
		warn("Bola n√£o encontrada.")
		return
	end

	ball = foundBall
	ball.Anchored = false
	ball.CanCollide = true
	ball.Massless = false

	clearForces(ball)
	ignorePlayerCollision(ball, character)

	-- For√ßa leve constante pra manter a bola flutuando
	local bodyForce = Instance.new("BodyForce")
	bodyForce.Force = Vector3.new(0, ball:GetMass() * workspace.Gravity, 0)
	bodyForce.Parent = ball

	local bodyPosition = Instance.new("BodyPosition")
	bodyPosition.MaxForce = Vector3.new(1e6, 1e6, 1e6)
	bodyPosition.P = 5e4
	bodyPosition.D = 1500
	bodyPosition.Parent = ball

	if connection then
		connection:Disconnect()
	end

	local toggle = true
	connection = RunService.Heartbeat:Connect(function()
		if not ball or not torso then
			connection:Disconnect()
			return
		end

		local forward = torso.CFrame.LookVector
		local offset = forward * (toggle and 2 or -2) -- DIST√ÇNCIA CURTA
		local basePos = torso.Position + Vector3.new(0, 1.5, 0) -- altura centralizada
		bodyPosition.Position = basePos + offset

		toggle = not toggle
	end)

	-- Reconecta caso o alvo renas√ßa
	targetPlayer.CharacterAdded:Connect(function()
		task.wait(1)
		setupBall()
	end)
end

-- Bot√£o que ativa o Fling com base no alvo selecionado
Tab2:AddButton({
	Name = "Fling Ball v3",
	Callback = function()
		if getgenv().Target then
			setupBall()
		else
			warn("Nenhum jogador selecionado. Use a dropdown primeiro.")
		end
	end
})

local Section = Tab2:AddSection({"<Combate Com  Sof√°-"})

local Players = game:GetService("Players")
local Player = Players.LocalPlayer
local Backpack = Player:FindFirstChild("Backpack")
local AllBool = false

getgenv().Target = nil -- Alvo global
getgenv().OldPos = nil -- Posi√ß√£o inicial antes do Fling

local function GetPlayer(Name)
    Name = Name:lower()
    for _, x in next, Players:GetPlayers() do
        if x ~= Player then
            if x.Name:lower():match("^" .. Name) or x.DisplayName:lower():match("^" .. Name) then
                return x
            end
        end
    end
    return nil
end

local function EquipCouch()
    if Backpack then
        local Couch = Backpack:FindFirstChild("Couch")
        if Couch and not Player.Character:FindFirstChild("Couch") then
            Player.Character.Humanoid:EquipTool(Couch)
        end
    end
end

local function UnequipCouch()
    if Player.Character then
        local Tool = Player.Character:FindFirstChildOfClass("Tool")
        if Tool and Tool.Name == "Couch" then
            Tool.Parent = Backpack
        end
    end
end

local function SafeReturn()
    local Player = game.Players.LocalPlayer
    local Character = Player.Character or Player.CharacterAdded:Wait()
    local RootPart = Character:FindFirstChild("HumanoidRootPart")
    local Humanoid = Character:FindFirstChildOfClass("Humanoid")

    if not RootPart or not Humanoid then  
        warn("RootPart ou Humanoid n√£o encontrado.")  
        return  
    end  

    -- Configura√ß√£o da posi√ß√£o fixa de retorno  
    local fixedReturnPos = Vector3.new(1118.81, 75.998, -1138.61)  

    -- Paralisa e trava o jogador  
    Humanoid.PlatformStand = true  
    RootPart.Anchored = true  
    RootPart.AssemblyLinearVelocity = Vector3.zero  
    RootPart.AssemblyAngularVelocity = Vector3.zero  

    -- Move direto para a posi√ß√£o definida  
    RootPart.CFrame = CFrame.new(fixedReturnPos)  
    print("Jogador teleportado para a posi√ß√£o segura.")  

    -- Fica travado por 3 segundos pra estabilizar  
    task.wait(3)  

    -- Libera o jogador  
    RootPart.Anchored = false  
    Humanoid.PlatformStand = false  
    print("Jogador liberado com seguran√ßa.")  
end

local function SkidFling(TargetPlayer)
    if not TargetPlayer then
        return
    end

    EquipCouch() -- Equipa o item Couch antes de iniciar o fling  

    local Character = Player.Character  
    local Humanoid = Character and Character:FindFirstChildOfClass("Humanoid")  
    local RootPart = Humanoid and Humanoid.RootPart  

    local TCharacter = TargetPlayer.Character  
    local TRootPart = TCharacter and TCharacter:FindFirstChild("HumanoidRootPart")  

    if not Character or not Humanoid or not RootPart or not TCharacter or not TRootPart then  
        return  
    end  

    -- Salva a posi√ß√£o inicial do jogador antes de iniciar o fling  
    if not getgenv().OldPos then  
        getgenv().OldPos = RootPart.CFrame  
    end  

    if RootPart.Velocity.Magnitude < 50 then  
        getgenv().OldPos = RootPart.CFrame  
    end  

    if TCharacter:FindFirstChildWhichIsA("Seat") then  
        UnequipCouch() -- Se o alvo estiver sentado, desequipa o Couch  
        return  
    end  

    local function FPos(BasePart, Pos, Ang)  
        RootPart.CFrame = CFrame.new(BasePart.Position) * Pos * Ang  
        Character:SetPrimaryPartCFrame(RootPart.CFrame)  
    end  

    local function SFBasePart(BasePart)  
        local StartTime = tick()  
        local Angle = 0  

        local BV = Instance.new("BodyVelocity")  
        BV.Parent = RootPart  
        BV.Velocity = Vector3.new(1000, 1000, 1000)  
        BV.MaxForce = Vector3.new(math.huge, math.huge, math.huge)  

        Humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, false)  

        repeat  
            Angle = Angle + 100  

            local THumanoid = TargetPlayer.Character:FindFirstChildOfClass("Humanoid")  
            local TRootPart = TCharacter and TCharacter:FindFirstChild("HumanoidRootPart")  

            if THumanoid then  
                if TCharacter:FindFirstChildWhichIsA("Seat") then  
                    UnequipCouch() -- Se o alvo sentar, desequipa o Couch  
                    return  
                end  

                -- Ajustando a altura e rota√ß√£o no alvo  
                FPos(BasePart, CFrame.new(0, 2, 0) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle), 0, 0))  
                task.wait()  
                FPos(BasePart, CFrame.new(0, -2, 0) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle), 0, 0))  
                task.wait()  
                FPos(BasePart, CFrame.new(2.5, 2, -2.5) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle), 0, 0))  
                task.wait()  
                FPos(BasePart, CFrame.new(-2.5, -2, 2.5) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle), 0, 0))  
                task.wait()  
                FPos(BasePart, CFrame.new(0, 2, 0) + THumanoid.MoveDirection, CFrame.Angles(math.rad(Angle), 0, 0))  
                task.wait()  
                FPos(BasePart, CFrame.new(0, -2, 0) + THumanoid.MoveDirection, CFrame.Angles(math.rad(Angle), 0, 0))  
                task.wait()  
            else  
                -- Comportamento alternativo se o humanoide n√£o for encontrado  
                FPos(BasePart, CFrame.new(0, 2, THumanoid.WalkSpeed), CFrame.Angles(math.rad(90), 0, 0))  
                task.wait()  
                FPos(BasePart, CFrame.new(0, -2, -THumanoid.WalkSpeed), CFrame.Angles(0, 0, 0))  
                task.wait()  
                FPos(BasePart, CFrame.new(0, 2, THumanoid.WalkSpeed), CFrame.Angles(math.rad(90), 0, 0))  
                task.wait()  
                FPos(BasePart, CFrame.new(0, 2, TRootPart.Velocity.Magnitude / 1.25), CFrame.Angles(math.rad(90), 0, 0))  
                task.wait()  
                FPos(BasePart, CFrame.new(0, -2, -TRootPart.Velocity.Magnitude / 1.25), CFrame.Angles(0, 0, 0))  
                task.wait()  
                FPos(BasePart, CFrame.new(0, 2, TRootPart.Velocity.Magnitude / 1.25), CFrame.Angles(math.rad(90), 0, 0))  
                task.wait()  
                FPos(BasePart, CFrame.new(0, -2, 0), CFrame.Angles(math.rad(90), 0, 0))  
                task.wait()  
                FPos(BasePart, CFrame.new(0, -2, 0), CFrame.Angles(0, 0, 0))  
                task.wait()  
                FPos(BasePart, CFrame.new(0, -2, 0), CFrame.Angles(math.rad(-90), 0, 0))  
                task.wait()  
                FPos(BasePart, CFrame.new(0, -2, 0), CFrame.Angles(0, 0, 0))  
                task.wait()  
            end  
        until tick() > StartTime + 3 -- Fling dura 3 segundos  

        -- No √∫ltimo segundo, desequipa o Couch e tira as for√ßas  
        UnequipCouch()  

        -- Remove a for√ßa de impulso e velocity  
        BV:Destroy()  

        -- Volta √† posi√ß√£o original com altura corrigida  
        local ReturnPos = getgenv().OldPos  
        if RootPart.Position.Y > ReturnPos.Position.Y then  
            -- Se o jogador foi lan√ßado para uma posi√ß√£o mais alta, devolve ele para a posi√ß√£o original com altura ajustada  
            ReturnPos = CFrame.new(ReturnPos.Position.X, ReturnPos.Position.Y - (RootPart.Position.Y - ReturnPos.Position.Y), ReturnPos.Position.Z)  
        end  

        -- Desabilita a f√≠sica antes de devolver o jogador  
        Humanoid.PlatformStand = true  

        -- Restaura a posi√ß√£o do jogador  
        RootPart.CFrame = ReturnPos  

        -- Habilita a f√≠sica novamente ap√≥s a restaura√ß√£o da posi√ß√£o  
        task.wait(1)  
        Humanoid.PlatformStand = false  
        Humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, true)

        -- Chama a fun√ß√£o de retorno seguro ap√≥s o Fling
        SafeReturn()
    end  

workspace.FallenPartsDestroyHeight = -math.huge  

SFBasePart(TRootPart)

end

Tab2:AddButton({
    Name = "Fling - V18",
    Callback = function()
        if getgenv().Target then
            local TargetPlayer = GetPlayer(getgenv().Target)
            if TargetPlayer then
                SkidFling(TargetPlayer)
            end
        end
    end
})


local Section = Tab2:AddSection({"<Combate  Com Ve√≠culo-"})

Tab2:AddButton({
    Name = " Bus - Fling",
    Callback = function()
        local Player = game.Players.LocalPlayer
        local Character = Player.Character
        local Humanoid = Character and Character:FindFirstChildOfClass("Humanoid")
        local RootPart = Character and Character:FindFirstChild("HumanoidRootPart")
        local Vehicles = workspace:FindFirstChild("Vehicles")
        local OldPos = RootPart and RootPart.CFrame

        if not Humanoid or not RootPart then return end

        local PCar = Vehicles:FindFirstChild(Player.Name.."Car")
        if not PCar then
            RootPart.CFrame = CFrame.new(1118.81, 75.998, -1138.61)
            task.wait(0.5)
            local Remote = game.ReplicatedStorage:FindFirstChild("RE") and game.ReplicatedStorage.RE:FindFirstChild("1Ca1r")
            if Remote then Remote:FireServer("PickingCar", "SchoolBus") end
            task.wait(0.5)
            PCar = Vehicles:FindFirstChild(Player.Name.."Car")
        end

        local timeout = 5
        while timeout > 0 and not PCar do
            task.wait(0.25)
            PCar = Vehicles:FindFirstChild(Player.Name.."Car")
            timeout -= 0.25
        end
        if not PCar then return end

        task.wait(0.5)
        if PCar and not Humanoid.Sit then
            local Seat = PCar:FindFirstChild("Body") and PCar.Body:FindFirstChild("VehicleSeat")
            if Seat then
                repeat task.wait()
                    RootPart.CFrame = Seat.CFrame
                until Humanoid.Sit
            end
        end

        local attachment = nil
        local force = nil

        -- Fun√ß√£o segura para recuperar alvo continuamente
        local function getTargetInfo()
            while true do
                local TargetPlayer = game.Players:FindFirstChild(getgenv().Target)
                if TargetPlayer then
                    local TargetC = TargetPlayer.Character
                    local TargetH = TargetC and TargetC:FindFirstChildOfClass("Humanoid")
                    local TargetRP = TargetC and TargetC:FindFirstChild("HumanoidRootPart")
                    if TargetC and TargetH and TargetRP then
                        return TargetC, TargetH, TargetRP
                    end
                end
                task.wait(0.2)
            end
        end

        local TargetC, TargetH, TargetRP = getTargetInfo()

        -- Aplica BodyVelocity no alvo
        attachment = Instance.new("Attachment", TargetRP)
        force = Instance.new("BodyVelocity")
        force.Velocity = Vector3.new(1e9, 1e9, 1e9)
        force.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
        force.P = 500
        force.Parent = attachment

        for _, part in ipairs(PCar:GetDescendants()) do
            if part:IsA("BasePart") then
                local bv = Instance.new("BodyVelocity")
                bv.Velocity = Vector3.new(1e9, 1e9, 1e9)
                bv.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
                bv.P = 500
                bv.Parent = part
            end
        end

        -- Loop principal com persist√™ncia
        local Angles = 0
        local YRotation = 0

        while PCar.Parent do
            task.wait()
            Angles += 100
            YRotation += 5000
            local Rotation = CFrame.Angles(math.rad(Angles), math.rad(YRotation), 0)

            -- Verifica se o alvo ainda existe; se n√£o, espera o retorno
            if not (TargetC and TargetH and TargetRP and TargetRP.Parent) then
                TargetC, TargetH, TargetRP = getTargetInfo()
                if attachment then attachment:Destroy() end
                if force then force:Destroy() end
                attachment = Instance.new("Attachment", TargetRP)
                force = Instance.new("BodyVelocity")
                force.Velocity = Vector3.new(1e9, 1e9, 1e9)
                force.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
                force.P = 500
                force.Parent = attachment
            end

            local function flingAttack(offset)
                local newPos = TargetRP.Position + offset + (TargetH.MoveDirection * TargetRP.Velocity.Magnitude / 1.1)
                local newCF = CFrame.new(newPos) * Rotation
                PCar:SetPrimaryPartCFrame(newCF)
            end

            flingAttack(Vector3.new(0, 1, 0))
            flingAttack(Vector3.new(0, -2.25, 5))
            flingAttack(Vector3.new(0, 2.25, 0.25))
            flingAttack(Vector3.new(-2.25, -1.5, 2.25))
            flingAttack(Vector3.new(0, 1.5, 0))
            flingAttack(Vector3.new(0, -1.5, 0))
        end

        -- Finaliza√ß√£o
        if attachment then attachment:Destroy() end
        if force then force:Destroy() end
        Humanoid.Sit = false
        task.wait(0.1)
        if OldPos then RootPart.CFrame = OldPos end
    end
})

Tab2:AddButton({
    Name = "Delisgar Fling - Bus",
    Callback = function()
        -- Executa o remote para deletar todos os ve√≠culos
        local args = {
            [1] = "DeleteAllVehicles"
        }
        game:GetService("ReplicatedStorage").RE:FindFirstChild("1Ca1r"):FireServer(unpack(args))

        -- Aguarda um frame para garantir que o remote foi processado (opcional, mas prudente)
        task.wait()

        local Player = game.Players.LocalPlayer
        local Character = Player.Character or Player.CharacterAdded:Wait()
        local RootPart = Character:FindFirstChild("HumanoidRootPart")
        local Humanoid = Character:FindFirstChildOfClass("Humanoid")

        if not RootPart or not Humanoid then
            warn("RootPart ou Humanoid n√£o encontrado.")
            return
        end

        -- Configura√ß√£o da posi√ß√£o fixa de retorno
        local fixedReturnPos = Vector3.new(1118.81, 75.998, -1138.61)

        -- Paralisa e trava o jogador
        Humanoid.PlatformStand = true
        RootPart.Anchored = true
        RootPart.AssemblyLinearVelocity = Vector3.zero
        RootPart.AssemblyAngularVelocity = Vector3.zero

        -- Move direto para a posi√ß√£o definida
        RootPart.CFrame = CFrame.new(fixedReturnPos)
        print("Jogador teleportado para a posi√ß√£o segura.")

        -- Fica travado por 3 segundos pra estabilizar
        task.wait(3)

        -- Libera o jogador
        RootPart.Anchored = false
        Humanoid.PlatformStand = false
        print("Jogador liberado com seguran√ßa.")
    end
})


Tab2:AddButton({
    Name = "Ban - House Kill v2",
    Callback = function()
        local Player = game.Players.LocalPlayer
        local Backpack = Player.Backpack
        local Character = Player.Character
        local Humanoid = Character:FindFirstChildOfClass("Humanoid")
        local RootPart = Character:FindFirstChild("HumanoidRootPart")
        local Houses = game.Workspace:FindFirstChild("001_Lots")
        local OldPos = RootPart.CFrame
        local Angles = 0
        local YRotation = 0
        local Vehicles = Workspace.Vehicles
        local Pos

        -- Function:
        function Check()
            return Player and Character and Humanoid and RootPart and Vehicles
        end

        -- Main:
        if not getgenv().Target then return end
        if Check() then
            local House = Houses:FindFirstChild(Player.Name.."House")
            if not House then
                local EHouse
                for _, Lot in pairs(Houses:GetChildren()) do
                    if Lot.Name == "For Sale" then
                        for _, num in pairs(Lot:GetDescendants()) do
                            if num:IsA("NumberValue") and num.Name == "Number" and num.Value < 25 and num.Value > 10 then
                                EHouse = Lot
                                break
                            end
                        end
                    end
                end

                local BuyDetector = EHouse:FindFirstChild("BuyHouse")
                Pos = BuyDetector.Position
                if BuyDetector and BuyDetector:IsA("BasePart") then
                    RootPart.CFrame = BuyDetector.CFrame + Vector3.new(0,-6,0)
                    task.wait(.5)
                    local ClickDetector = BuyDetector:FindFirstChild("ClickDetector")
                    if ClickDetector then
                        fireclickdetector(ClickDetector)
                    end
                end
            end

            task.wait(0.5)
            local PreHouse = Houses:FindFirstChild(Player.Name .. "House")
            if PreHouse then
                task.wait(0.5)
                local Number
                for _, x in pairs(PreHouse:GetDescendants()) do
                    if x.Name == "Number" and x:IsA("NumberValue") then
                        Number = x
                    end
                end
                task.wait(0.5)
                game:GetService("ReplicatedStorage").RE:FindFirstChild("1Gettin1gHous1e"):FireServer("PickingCustomHouse", "052_House", Number.Value)
            end

            task.wait(0.5)
            local PCar = Vehicles:FindFirstChild(Player.Name.."Car")
            if not PCar then
                if Check() then
                    RootPart.CFrame = CFrame.new(1118.81, 75.998, -1138.61)
                    task.wait(0.5)
                    game:GetService("ReplicatedStorage").RE:FindFirstChild("1Ca1r"):FireServer("PickingCar", "SchoolBus")
                    task.wait(0.5)
                    PCar = Vehicles:FindFirstChild(Player.Name.."Car")
                    task.wait(0.5)
                    local Seat = PCar and PCar:FindFirstChild("Body") and PCar.Body:FindFirstChild("VehicleSeat")
                    if Seat then
                        repeat task.wait()
                            RootPart.CFrame = Seat.CFrame * CFrame.new(0, math.random(-1, 1), 0)
                        until Humanoid.Sit
                    end
                end
            end

            task.wait(0.5)
            PCar = Vehicles:FindFirstChild(Player.Name.."Car")
            if PCar then
                if not Humanoid.Sit then
                    local Seat = PCar:FindFirstChild("Body") and PCar.Body:FindFirstChild("VehicleSeat")
                    if Seat then
                        repeat task.wait()
                            RootPart.CFrame = Seat.CFrame * CFrame.new(0, math.random(-1, 1), 0)
                        until Humanoid.Sit
                    end
                end

                local Target = game.Players:FindFirstChild(getgenv().Target)
                local TargetC = Target and Target.Character
                local TargetH = TargetC and TargetC:FindFirstChildOfClass("Humanoid")
                local TargetRP = TargetC and TargetC:FindFirstChild("HumanoidRootPart")

                if TargetC and TargetH and TargetRP then
                    if not TargetH.Sit then
                        while not TargetH.Sit do
                            task.wait()
                            local Fling = function(alvo, pos, angulo)
                                PCar:SetPrimaryPartCFrame(CFrame.new(alvo.Position) * pos * angulo)
                            end
                            
                            -- Aumentando a rota√ß√£o progressivamente
                            Angles = Angles + 100
                            YRotation = YRotation + 5000  -- Adicionando rota√ß√£o no eixo Y

                            local Rotation = CFrame.Angles(math.rad(Angles), math.rad(YRotation), 0)

                            Fling(TargetRP, CFrame.new(0, 1.5, 0) + TargetH.MoveDirection * TargetRP.Velocity.Magnitude / 1.10, Rotation)
                            Fling(TargetRP, CFrame.new(0, -1.5, 0) + TargetH.MoveDirection * TargetRP.Velocity.Magnitude / 1.10, Rotation)
                            Fling(TargetRP, CFrame.new(2.25, 1.5, -2.25) + TargetH.MoveDirection * TargetRP.Velocity.Magnitude / 1.10, Rotation)
                            Fling(TargetRP, CFrame.new(-2.25, -1.5, 2.25) + TargetH.MoveDirection * TargetRP.Velocity.Magnitude / 1.10, Rotation)
                        end

                        task.wait(0.2)
                        local House = Houses:FindFirstChild(Player.Name.."House")
                        PCar:SetPrimaryPartCFrame(CFrame.new(House.HouseSpawnPosition.Position))
                        task.wait(0.2)
                        local Region = Region3.new(RootPart.Position - Vector3.new(30,30,30), RootPart.Position + Vector3.new(30,30,30))
                        local Parts = workspace:FindPartsInRegion3(Region, RootPart, math.huge)

                        for _, v in pairs(Parts) do
                            if v.Name == "HumanoidRootPart" then
                                local BannedPlayer = game:GetService("Players"):FindFirstChild(v.Parent.Name)
                                local args = { "BanPlayerFromHouse", BannedPlayer, v.Parent }
                                game:GetService("ReplicatedStorage").RE:FindFirstChild("1Playe1rTrigge1rEven1t"):FireServer(unpack(args))

                                local argsDelete = { "DeleteAllVehicles" }
                                game:GetService("ReplicatedStorage").RE:FindFirstChild("1Ca1r"):FireServer(unpack(argsDelete))
                            end
                        end
                    end
                end
            end
        end
    end
})

Tab2:AddButton({
    Name = "Car - Kill",
    Callback = function()
        local Target = getgenv().Target
        local Player = game.Players.LocalPlayer
        local Character = Player.Character
        local Humanoid = Character:FindFirstChildOfClass("Humanoid")
        local RootPart = Character:FindFirstChild("HumanoidRootPart")
        local Vehicles = game.Workspace:FindFirstChild("Vehicles")
        local OldPos = RootPart.CFrame

        if not Target or not Humanoid then return end

        local PCar = Vehicles:FindFirstChild(Player.Name.."Car")
        if not PCar then
            if RootPart and Target then 
                RootPart.CFrame = CFrame.new(1118.81, 75.998, -1138.61)
                task.wait(0.5)
                game:GetService("ReplicatedStorage").RE:FindFirstChild("1Ca1r"):FireServer("PickingCar", "SchoolBus")
                task.wait(0.5)
                PCar = Vehicles:FindFirstChild(Player.Name.."Car")
                task.wait(0.5)
                local Seat = PCar:FindFirstChild("Body") and PCar.Body:FindFirstChild("VehicleSeat")
                if Seat then
                    repeat task.wait()
                        RootPart.CFrame = Seat.CFrame
                    until Humanoid.Sit
                end
            end
        end

        task.wait(0.5)
        PCar = Vehicles:FindFirstChild(Player.Name.."Car")
        if PCar and not Humanoid.Sit then
            local Seat = PCar:FindFirstChild("Body") and PCar.Body:FindFirstChild("VehicleSeat")
            if Seat then
                repeat task.wait()
                    RootPart.CFrame = Seat.CFrame
                until Humanoid.Sit
            end
        end

        local TargetPlayer = game.Players:FindFirstChild(getgenv().Target)
        if TargetPlayer then
            local TargetC = TargetPlayer.Character
            local TargetH = TargetC and TargetC:FindFirstChildOfClass("Humanoid")
            local TargetRP = TargetC and TargetC:FindFirstChild("HumanoidRootPart")

            if TargetC and TargetH and TargetRP then
                if not TargetH.Sit then
                    local Angles = 0
                    local YRotation = 0

                    while not TargetH.Sit do
                        task.wait()

                        -- Mantendo a rota√ß√£o alinhada com a l√≥gica do "Ban - House"
                        Angles = Angles + 100
                        YRotation = YRotation + 5000
                        local Rotation = CFrame.Angles(math.rad(Angles), math.rad(YRotation), 0)

                        -- Fun√ß√£o para movimentar o carro e alinhar o ataque
                        local kill = function(alvo, pos)
                            local newPosition = alvo.Position + pos + (TargetH.MoveDirection * TargetRP.Velocity.Magnitude / 1.05)
                            local newCFrame = CFrame.new(newPosition) * Rotation
                            PCar:SetPrimaryPartCFrame(newCFrame)
                        end

                        -- Movimentos do carro ao redor do jogador alvo
                        kill(TargetRP, Vector3.new(0, 1, 0))
                        kill(TargetRP, Vector3.new(0, -2.25, 5))
                        kill(TargetRP, Vector3.new(0, 2.25, 0.25))
                        kill(TargetRP, Vector3.new(-2.25, -1.5, 2.25))
                        kill(TargetRP, Vector3.new(0, 1.5, 0))
                        kill(TargetRP, Vector3.new(0, -1.5, 0))
                    end

                    -- Movimenta o carro para longe ao final
                    task.wait(0.1)
                    PCar:SetPrimaryPartCFrame(CFrame.new(0, -470, 0))
                    task.wait(0.2)

                    -- Finaliza√ß√£o
                    Humanoid.Sit = false
                    task.wait(0.1)
                    RootPart.CFrame = OldPos
                end
            end
        end
    end
})


local function bringPlayer()
    local Target = getgenv().Target
    local Player = game.Players.LocalPlayer
    local Character = Player.Character
    local Humanoid = Character:FindFirstChildOfClass("Humanoid")
    local RootPart = Character:FindFirstChild("HumanoidRootPart")
    local Vehicles = game.Workspace:FindFirstChild("Vehicles")
    local OldPos = RootPart.CFrame -- Guardar a posi√ß√£o original do jogador

    if not Target or not Humanoid then return end

    -- Verificar e spawnar o carro se necess√°rio
    local PCar = Vehicles:FindFirstChild(Player.Name .. "Car")
    if not PCar then
        if RootPart and Target then
            RootPart.CFrame = CFrame.new(1118.81, 75.998, -1138.61) -- Teleporte inicial
            task.wait(0.5)
            game:GetService("ReplicatedStorage").RE:FindFirstChild("1Ca1r"):FireServer("PickingCar", "SchoolBus")
            task.wait(0.5)
            PCar = Vehicles:FindFirstChild(Player.Name .. "Car")
            task.wait(0.5)
            local Seat = PCar:FindFirstChild("Body") and PCar.Body:FindFirstChild("VehicleSeat")
            if Seat then
                repeat task.wait()
                    RootPart.CFrame = Seat.CFrame
                until Humanoid.Sit
            end
        end
    end

    -- Repetir processo se o carro j√° foi criado
    task.wait(0.5)
    PCar = Vehicles:FindFirstChild(Player.Name .. "Car")
    if PCar and not Humanoid.Sit then
        local Seat = PCar:FindFirstChild("Body") and PCar.Body:FindFirstChild("VehicleSeat")
        if Seat then
            repeat task.wait()
                RootPart.CFrame = Seat.CFrame
            until Humanoid.Sit
        end
    end

    -- Encontrar o alvo
    local TargetPlayer = game.Players:FindFirstChild(getgenv().Target)
    local TargetC = TargetPlayer and TargetPlayer.Character
    local TargetH = TargetC and TargetC:FindFirstChildOfClass("Humanoid")
    local TargetRP = TargetC and TargetC:FindFirstChild("HumanoidRootPart")

    -- Teletransportar e fazer o "bring" no alvo
    if TargetC and TargetH and TargetRP then
        if not TargetH.Sit then
            local Angles = 0
            local YRotation = 0

            while not TargetH.Sit do
                task.wait()

                -- Mantendo a rota√ß√£o alinhada com a l√≥gica
                Angles = Angles + 100
                YRotation = YRotation + 5000
                local Rotation = CFrame.Angles(math.rad(Angles), math.rad(YRotation), 0)

                -- Fun√ß√£o para movimentar o carro e alinhar o ataque
                local bring = function(alvo, pos)
                    local newPosition = alvo.Position + pos + (TargetH.MoveDirection * TargetRP.Velocity.Magnitude / 1.05)
                    local newCFrame = CFrame.new(newPosition) * Rotation
                    PCar:SetPrimaryPartCFrame(newCFrame)
                end

                -- Movimentos do carro ao redor do jogador alvo
                bring(TargetRP, Vector3.new(0, 1, 0))
                bring(TargetRP, Vector3.new(0, -2.25, 5))
                bring(TargetRP, Vector3.new(0, 2.25, 0.25))
                bring(TargetRP, Vector3.new(-2.25, -1.5, 2.25))
                bring(TargetRP, Vector3.new(0, 1.5, 0))
                bring(TargetRP, Vector3.new(0, -1.5, 0))
            end

            -- Quando o alvo sentar, teleportar de volta para a posi√ß√£o antiga
            task.wait(0.1)
            PCar:SetPrimaryPartCFrame(OldPos) -- Aqui o carro vai para a sua posi√ß√£o antiga (OldPos)
            task.wait(0.2)
            Humanoid.Sit = false
            task.wait(0.1)

            -- Executar a fun√ß√£o DeleteAllVehicles ap√≥s 0.5 segundos
            task.wait(0.1)
            game:GetService("ReplicatedStorage").RE:FindFirstChild("1Ca1r"):FireServer("DeleteAllVehicles")
        end
    end
end

-- Adicionando o bot√£o
Tab2:AddButton({
    Name = " Car - Bring",
    Callback = function()
        bringPlayer()
    end
})

local Section = Tab2:AddSection({"<Combate Em All-"})

Tab2:AddButton({
    Name = "Press! Bus - Fling All",
    Callback = function()
        local Player = game.Players.LocalPlayer
        local Character = Player.Character
        local Humanoid = Character and Character:FindFirstChildOfClass("Humanoid")
        local RootPart = Character and Character:FindFirstChild("HumanoidRootPart")
        local Vehicles = workspace:FindFirstChild("Vehicles")
        local OldPos = RootPart and RootPart.CFrame

        if not Humanoid or not RootPart then return end

        local PCar = Vehicles:FindFirstChild(Player.Name.."Car")
        if not PCar then
            RootPart.CFrame = CFrame.new(1118.81, 75.998, -1138.61)
            task.wait(0.5)
            local Remote = game.ReplicatedStorage:FindFirstChild("RE") and game.ReplicatedStorage.RE:FindFirstChild("1Ca1r")
            if Remote then Remote:FireServer("PickingCar", "SchoolBus") end
            task.wait(0.5)
            PCar = Vehicles:FindFirstChild(Player.Name.."Car")
        end

        local timeout = 5
        while timeout > 0 and not PCar do
            task.wait(0.25)
            PCar = Vehicles:FindFirstChild(Player.Name.."Car")
            timeout -= 0.25
        end
        if not PCar then return end

        task.wait(0.5)
        if PCar and not Humanoid.Sit then
            local Seat = PCar:FindFirstChild("Body") and PCar.Body:FindFirstChild("VehicleSeat")
            if Seat then
                repeat task.wait()
                    RootPart.CFrame = Seat.CFrame
                until Humanoid.Sit
            end
        end

        -- Aplica BodyVelocity no carro
        for _, part in ipairs(PCar:GetDescendants()) do
            if part:IsA("BasePart") then
                local bv = Instance.new("BodyVelocity")
                bv.Velocity = Vector3.new(1e9, 1e9, 1e9)
                bv.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
                bv.P = 500
                bv.Parent = part
            end
        end

        -- Loop cont√≠nuo para aplicar o fling em todos os jogadores
        task.spawn(function()
            local Angles = 0
            local YRotation = 0

            while PCar.Parent do
                for _, target in ipairs(game.Players:GetPlayers()) do
                    if target ~= Player then
                        local TargetC = target.Character
                        local TargetH = TargetC and TargetC:FindFirstChildOfClass("Humanoid")
                        local TargetRP = TargetC and TargetC:FindFirstChild("HumanoidRootPart")

                        if TargetC and TargetH and TargetRP then
                            -- Cria for√ßas para fling
                            local attachment = Instance.new("Attachment", TargetRP)
                            local force = Instance.new("BodyVelocity")
                            force.Velocity = Vector3.new(1e9, 1e9, 1e9)
                            force.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
                            force.P = 500
                            force.Parent = attachment

                            local startTime = tick()
                            while tick() - startTime < 2 and TargetRP.Parent and PCar.Parent do
                                task.wait()
                                Angles += 100
                                YRotation += 5000
                                local Rotation = CFrame.Angles(math.rad(Angles), math.rad(YRotation), 0)

                                local function flingAttack(offset)
                                    local newPos = TargetRP.Position + offset + (TargetH.MoveDirection * TargetRP.Velocity.Magnitude / 1.1)
                                    local newCF = CFrame.new(newPos) * Rotation
                                    PCar:SetPrimaryPartCFrame(newCF)
                                end

                                flingAttack(Vector3.new(0, 1, 0))
                                flingAttack(Vector3.new(0, -2.25, 5))
                                flingAttack(Vector3.new(0, 2.25, 0.25))
                                flingAttack(Vector3.new(-2.25, -1.5, 2.25))
                                flingAttack(Vector3.new(0, 1.5, 0))
                                flingAttack(Vector3.new(0, -1.5, 0))
                            end

                            -- Limpa for√ßas ao trocar de alvo
                            attachment:Destroy()
                            force:Destroy()
                        end
                    end
                end
            end
        end)

        -- Cleanup final quando ve√≠culo for removido
        repeat task.wait() until not PCar or not PCar.Parent
        Humanoid.Sit = false
        task.wait(0.1)
        if OldPos then RootPart.CFrame = OldPos end
    end
})

-- Servi√ßos
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

-- Jogador local e caminho da bola
local localPlayer = Players.LocalPlayer
local BALL_PATH = "WorkspaceCom/001_SoccerBalls/Soccer" .. localPlayer.Name

-- Vari√°veis globais
getgenv().Target = nil
local ball, connection
local isFlinging = false  -- Controla se o Fling Ball est√° ativo

-- Remove qualquer for√ßa existente na bola
local function clearForces(targetBall)
	for _, obj in ipairs(targetBall:GetChildren()) do
		if obj:IsA("BodyForce") or obj:IsA("BodyVelocity") or obj:IsA("BodyPosition") then
			obj:Destroy()
		end
	end
end

-- Ignora colis√£o entre a bola e o personagem
local function ignorePlayerCollision(targetBall, targetCharacter)
	for _, part in ipairs(targetCharacter:GetDescendants()) do
		if part:IsA("BasePart") then
			local constraint = Instance.new("NoCollisionConstraint")
			constraint.Part0 = targetBall
			constraint.Part1 = part
			constraint.Parent = targetBall
		end
	end
end

-- Aplica for√ßa extrema na bola
local function applyFlingForces(targetBall)
	clearForces(targetBall)

	local bodyForce = Instance.new("BodyForce")
	bodyForce.Force = Vector3.new(5e7, 5e7, 5e7)
	bodyForce.Parent = targetBall

	local bodyVelocity = Instance.new("BodyVelocity")
	bodyVelocity.Velocity = Vector3.new(9e6, 9e6, 9e6)
	bodyVelocity.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
	bodyVelocity.P = 4e7
	bodyVelocity.Parent = targetBall
end

-- Configura a bola para seguir o alvo e causar fling
function setupBall()
	local targetName = getgenv().Target
	if not targetName then return end

	local targetPlayer = Players:FindFirstChild(targetName)
	if not targetPlayer then return end

	local character = targetPlayer.Character or targetPlayer.CharacterAdded:Wait()
	local torso = character:FindFirstChild("UpperTorso") or character:FindFirstChild("Torso")
	if not torso then return end

	local success, foundBall = pcall(function()
		local obj = workspace
		for _, part in ipairs(BALL_PATH:split("/")) do
			obj = obj:WaitForChild(part, 5)
		end
		return obj
	end)

	if not success or not foundBall then return end

	ball = foundBall
	ball.Anchored = false
	ball.CanCollide = true
	ball.Massless = false

	clearForces(ball)
	ignorePlayerCollision(ball, character)
	applyFlingForces(ball)

	if connection then connection:Disconnect() end

	local toggle = true
	connection = RunService.Heartbeat:Connect(function()
		if not ball or not torso then
			connection:Disconnect()
			return
		end

		local forward = torso.CFrame.LookVector
		local basePos = torso.Position + Vector3.new(0, 0.5, 0)
		local offset = forward * (toggle and 35 or -35)
		ball.CFrame = CFrame.new(basePos + offset)
		toggle = not toggle
	end)

	targetPlayer.CharacterAdded:Connect(function()
		task.wait(1)
		setupBall()
	end)
end

-- Ciclo autom√°tico de fling em todos os jogadores
local function startFlingBallAll()
	isFlinging = true
	while isFlinging do
		local allPlayers = Players:GetPlayers()
		for _, player in ipairs(allPlayers) do
			if player ~= localPlayer then
				getgenv().Target = player.Name
				setupBall()
				task.wait(3)
			end
		end
	end
end

-- Bot√£o que ativa o Fling Ball em todos os jogadores
Tab2:AddButton({
	Name = "Fling Ball All",
	Callback = function()
		if not isFlinging then
			startFlingBallAll()
		else
			warn("O Fling Ball j√° est√° ativo em todos os jogadores.")
		end
	end
})

Tab2:AddButton({
    Name = "Fling Bus - All",
    Callback = function()
        local Player = game.Players.LocalPlayer
        local Character = Player.Character
        local Humanoid = Character and Character:FindFirstChildOfClass("Humanoid")
        local RootPart = Character and Character:FindFirstChild("HumanoidRootPart")
        local Vehicles = game.Workspace:FindFirstChild("Vehicles")

        -- Lista de jogadores na whitelist
        local Whitelist = {
            ["kauxz016"] = true,
            ["goduser573"] = true,
            ["NOEL_A21S"] = true,
            ["Usuario_X1x1x1"] = true,
            ["Myst_gamemy34"] = true,
            ["vehshddhdhdhh"] = true,
        }

        if not Humanoid or not RootPart then
            warn("Jogador sem Humanoid/RootPart")
            return
        end

        -- Fun√ß√£o para spawnar o barco
        local function spawnBoat()
            RootPart.CFrame = CFrame.new(1118.81, 75.998, -1138.61)
            task.wait(0.5)
            game:GetService("ReplicatedStorage").RE:FindFirstChild("1Ca1r"):FireServer("PickingCar", "SchoolBus")
            task.wait(1)
            return Vehicles:FindFirstChild(Player.Name.."Car")
        end

        -- Garante que o barco foi spawnado
        local PCar = Vehicles:FindFirstChild(Player.Name.."Car") or spawnBoat()
        if not PCar then
            warn("Falha ao spawnar o barco")
            return
        end

        -- Aguarda o assento do barco
        local Seat = PCar:FindFirstChild("Body") and PCar.Body:FindFirstChild("VehicleSeat")
        if not Seat then
            warn("Nenhum assento encontrado no barco")
            return
        end

        -- Tenta sentar no barco
        repeat 
            task.wait()
            RootPart.CFrame = Seat.CFrame * CFrame.new(0, math.random(-1, 1), 0)
        until Humanoid.Sit

        -- Criando e adicionando o SpinGyro no barco
        local SpinGyro = Instance.new("BodyGyro")
        SpinGyro.Parent = PCar.PrimaryPart
        SpinGyro.MaxTorque = Vector3.new(1e12, 1e12, 1e12) -- Torque maior para maior rota√ß√£o
        SpinGyro.P = 1e12 -- Pot√™ncia aumentada para rota√ß√£o mais r√°pida
        SpinGyro.CFrame = PCar.PrimaryPart.CFrame

        print("SpinGyro ativado no barco! Rota√ß√£o centr√≠fuga aplicada!")

        -- Fun√ß√£o para realizar o fling em um alvo espec√≠fico
        local function flingTarget(TargetPlayer)
            local TargetC = TargetPlayer.Character
            local TargetH = TargetC and TargetC:FindFirstChildOfClass("Humanoid")
            local TargetRP = TargetC and TargetC:FindFirstChild("HumanoidRootPart")

            if not TargetRP or not TargetH then
                warn("Alvo sem Humanoid/RootPart")
                return
            end

            local angle = 0
            local radius = 5
            local speed = 0.1
            local expansionRate = 0.2

            -- Loop de 3 segundos para o fling no jogador atual
            local startTime = tick()
            while tick() - startTime < 3 and PCar and PCar.Parent do
                task.wait(0.1)

                local offsetX = math.cos(angle) * radius
                local offsetZ = math.sin(angle) * radius
                local moveTo = TargetRP.Position + Vector3.new(offsetX, 0, offsetZ)

                PCar:SetPrimaryPartCFrame(CFrame.new(moveTo) * CFrame.Angles(0, math.rad(180), 0))

                angle = angle + speed
                radius = math.max(radius - expansionRate, 1)

                if (PCar.PrimaryPart.Position - TargetRP.Position).Magnitude < 3 then
                    speed = speed + 0.2
                    expansionRate = expansionRate + 0.1
                end
            end
        end

        -- Loop para alternar entre os jogadores
        task.spawn(function()
            while PCar and PCar.Parent do
                for _, TargetPlayer in pairs(game.Players:GetPlayers()) do
                    if TargetPlayer ~= Player and not Whitelist[TargetPlayer.Name] then
                        flingTarget(TargetPlayer)
                    end
                end
            end
        end)
    end
})

local Players = game:GetService("Players")
local Player = Players.LocalPlayer
local Backpack = Player:FindFirstChild("Backpack")
local AllBool = false

getgenv().Target = nil -- Alvo global
local forceActive = false -- Controla se a for√ßa est√° ativa
local BV -- Vari√°vel para armazenar a BodyVelocity

local function GetPlayer(Name)
    Name = Name:lower()
    for _, x in next, Players:GetPlayers() do
        if x ~= Player then
            if x.Name:lower():match("^" .. Name) or x.DisplayName:lower():match("^" .. Name) then
                return x
            end
        end
    end
    return nil
end

local function EquipCouch()
    if Backpack then
        local Couch = Backpack:FindFirstChild("Couch")
        if Couch then
            Player.Character.Humanoid:EquipTool(Couch)
        end
    end
end

local function UnequipCouch()
    -- N√£o vamos permitir que o Couch seja desequipado
end

local function SkidFling(TargetPlayer)
    if not TargetPlayer then
        return
    end

    EquipCouch() -- Equipa o item Couch antes de iniciar o fling

    local Character = Player.Character
    local Humanoid = Character and Character:FindFirstChildOfClass("Humanoid")
    local RootPart = Humanoid and Humanoid.RootPart

    local TCharacter = TargetPlayer.Character
    local TRootPart = TCharacter and TCharacter:FindFirstChild("HumanoidRootPart")

    if not Character or not Humanoid or not RootPart or not TCharacter or not TRootPart then
        return
    end

    if RootPart.Velocity.Magnitude < 50 then
        getgenv().OldPos = RootPart.CFrame
    end

    if TCharacter:FindFirstChildWhichIsA("Seat") then
        UnequipCouch() -- Se o alvo estiver sentado, desequipa o Couch
        return
    end

    local function FPos(BasePart, Pos, Ang)
        RootPart.CFrame = CFrame.new(BasePart.Position) * Pos * Ang
        Character:SetPrimaryPartCFrame(RootPart.CFrame)
        RootPart.Velocity = Vector3.new(1e19, 1e19, 1e19)
    end

    local function SFBasePart(BasePart)
        local StartTime = tick()
        local Angle = 0

        repeat
            Angle = Angle + 100

            local THumanoid = TargetPlayer.Character:FindFirstChildOfClass("Humanoid")
            local TRootPart = TCharacter and TCharacter:FindFirstChild("HumanoidRootPart")

            if THumanoid then
                if TCharacter:FindFirstChildWhichIsA("Seat") then
                    UnequipCouch() -- Se o alvo sentar, desequipa o Couch
                    return
                end

                FPos(BasePart, CFrame.new(0, 1.5, 0) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle), 0, 0))
                task.wait()
                FPos(BasePart, CFrame.new(0, -1.5, 0) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle), 0, 0))
                task.wait()
                FPos(BasePart, CFrame.new(2.25, 1.5, -2.25) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle), 0, 0))
                task.wait()
                FPos(BasePart, CFrame.new(-2.25, -1.5, 2.25) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle), 0, 0))
                task.wait()
                FPos(BasePart, CFrame.new(0, 1.5, 0) + THumanoid.MoveDirection, CFrame.Angles(math.rad(Angle), 0, 0))
                task.wait()
                FPos(BasePart, CFrame.new(0, -1.5, 0) + THumanoid.MoveDirection, CFrame.Angles(math.rad(Angle), 0, 0))
                task.wait()
            else
                -- Comportamento alternativo se o humanoide n√£o for encontrado
                FPos(BasePart, CFrame.new(0, 1.5, THumanoid.WalkSpeed), CFrame.Angles(math.rad(90), 0, 0))
                task.wait()
                FPos(BasePart, CFrame.new(0, -1.5, -THumanoid.WalkSpeed), CFrame.Angles(0, 0, 0))
                task.wait()
                FPos(BasePart, CFrame.new(0, 1.5, THumanoid.WalkSpeed), CFrame.Angles(math.rad(90), 0, 0))
                task.wait()
                FPos(BasePart, CFrame.new(0, 1.5, TRootPart.Velocity.Magnitude / 1.25), CFrame.Angles(math.rad(90), 0, 0))
                task.wait()
                FPos(BasePart, CFrame.new(0, -1.5, -TRootPart.Velocity.Magnitude / 1.25), CFrame.Angles(0, 0, 0))
                task.wait()
                FPos(BasePart, CFrame.new(0, 1.5, TRootPart.Velocity.Magnitude / 1.25), CFrame.Angles(math.rad(90), 0, 0))
                task.wait()
                FPos(BasePart, CFrame.new(0, -1.5, 0), CFrame.Angles(math.rad(90), 0, 0))
                task.wait()
                FPos(BasePart, CFrame.new(0, -1.5, 0), CFrame.Angles(0, 0, 0))
                task.wait()
                FPos(BasePart, CFrame.new(0, -1.5, 0), CFrame.Angles(math.rad(-90), 0, 0))
                task.wait()
                FPos(BasePart, CFrame.new(0, -1.5, 0), CFrame.Angles(0, 0, 0))
                task.wait()
            end
        until BasePart.Parent ~= TargetPlayer.Character or Humanoid.Health <= 0 or tick() > StartTime + 2 or TCharacter:FindFirstChildWhichIsA("Seat")
    end

    workspace.FallenPartsDestroyHeight = -math.huge

    -- Configura a for√ßa (BodyVelocity) com "um googolplex de for√ßa" (simbolicamente math.huge)
    BV = Instance.new("BodyVelocity")
    BV.Parent = RootPart
    BV.Velocity = Vector3.new(1e12, 1e12, 1e12)
    BV.MaxForce = Vector3.new(math.huge, math.huge, math.huge) -- M√°xima for√ßa poss√≠vel no Roblox (equivalente a "infinito")

    Humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, false)

    SFBasePart(TRootPart)

    -- Deixa a for√ßa ativa at√© o final
    forceActive = true

    Humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, true)

    RootPart.CFrame = getgenv().OldPos * CFrame.new(0, .5, 0)
    Humanoid.PlatformStand = true

    task.wait(1)
    Humanoid.PlatformStand = false

    -- Remove a for√ßa apenas no final da fun√ß√£o
    if BV then
        BV:Destroy()
    end
end

local function onDeath()
    -- Interrompe o Fling e a for√ßa se o jogador morrer
    forceActive = false
    if BV then
        BV:Destroy() -- Remove a BodyVelocity
    end
end

Player.Character:WaitForChild("Humanoid").Died:Connect(onDeath)

Tab2:AddButton({
    Name = "Fast - Fling All",
    Callback = function()
        local players = Players:GetPlayers()
        local playerIndex = 1

        local function FlingNextPlayer()
            if playerIndex <= #players then
                local TargetPlayer = players[playerIndex]

                if TargetPlayer == Player then
                    playerIndex = playerIndex + 1
                    return FlingNextPlayer()
                end

                -- Pede o item Couch
                local args = {
                    [1] = "PickingTools",
                    [2] = "Couch"
                }

                local remoteFunction = game:GetService("ReplicatedStorage").RE:FindFirstChild("1Too1l")
                if remoteFunction then
                    remoteFunction:InvokeServer(unpack(args))
                    task.wait(0.2)
                end

                EquipCouch()
                task.wait(0.1)

                SkidFling(TargetPlayer)
                UnequipCouch()
                task.wait(0.2)

                playerIndex = playerIndex + 1
                FlingNextPlayer()
            end
        end

        FlingNextPlayer()
    end
})

Tab2:AddButton({
    Name = "House Kill - All",
    Callback = function()
        local Player = game.Players.LocalPlayer
        local Backpack = Player.Backpack
        local Character = Player.Character
        local Humanoid = Character:FindFirstChildOfClass("Humanoid")
        local RootPart = Character:FindFirstChild("HumanoidRootPart")
        local Houses = game.Workspace:FindFirstChild("001_Lots")
        local Vehicles = Workspace.Vehicles

        -- Lista atualizada de nomes de usu√°rios na whitelist
        local Whitelist = {
            ["kauxz016"] = true,
            ["goduser573"] = true,
            ["NOEL_A21S"] = true,
            ["Usuario_X1x1x1"] = true,
            ["Myst_gamemy34"] = true,
            ["vehshddhdhdhh"] = true,
        }

        function Check()
            return Player and Character and Humanoid and RootPart and Vehicles
        end

        local function SpawnCar()
            if Check() then
                local PCar = Vehicles:FindFirstChild(Player.Name.."Car")
                if not PCar then
                    RootPart.CFrame = CFrame.new(1118.81, 75.998, -1138.61)
                    task.wait(0.5)
                    game:GetService("ReplicatedStorage").RE:FindFirstChild("1Ca1r"):FireServer("PickingCar", "SchoolBus")
                    task.wait(0.5)
                    PCar = Vehicles:FindFirstChild(Player.Name.."Car")
                    task.wait(0.5)
                    local Seat = PCar:FindFirstChild("Body") and PCar.Body:FindFirstChild("VehicleSeat")
                    if Seat then
                        repeat task.wait()
                            RootPart.CFrame = Seat.CFrame * CFrame.new(0, math.random(-1, 1), 0)
                        until Humanoid.Sit
                    end
                end
            end
        end

        if Check() then
            for _, Target in pairs(game.Players:GetPlayers()) do
                if Target ~= Player and Target.Character then
                    -- Verifica se o nome do jogador est√° na whitelist
                    if not Whitelist[Target.Name] then
                        local TargetC = Target.Character
                        local TargetH = TargetC:FindFirstChildOfClass("Humanoid")
                        local TargetRP = TargetC:FindFirstChild("HumanoidRootPart")
                        if TargetH and TargetRP then
                            SpawnCar()

                            if not TargetH.Sit then
                                local Angles = 0 -- Inicializa a rota√ß√£o
                                local startTime = os.clock() -- Marca o tempo de in√≠cio
                                local timeLimit = 5 -- Limite de tempo em segundos

                                while not TargetH.Sit do
                                    task.wait()
                                    -- Verifica se o tempo limite foi excedido
                                    if os.clock() - startTime > timeLimit then
                                        break -- Sair do loop e ir para o pr√≥ximo alvo
                                    end

                                    local Fling = function(alvo, pos, angulo)
                                        local PCar = Vehicles:FindFirstChild(Player.Name.."Car")
                                        if PCar then
                                            PCar:SetPrimaryPartCFrame(CFrame.new(alvo.Position) * pos * angulo)
                                        end
                                    end

                                    -- Aumentando a rota√ß√£o progressivamente
                                    Angles = Angles + 100
                                    local Rotation = CFrame.Angles(0, math.rad(Angles), 0) -- Mant√©m a rota√ß√£o apenas no eixo Y

                                    Fling(TargetRP, CFrame.new(0, 1, 0) + TargetH.MoveDirection * TargetRP.Velocity.Magnitude / 1.10, Rotation)
                                    Fling(TargetRP, CFrame.new(0, -1.5, 0) + TargetH.MoveDirection * TargetRP.Velocity.Magnitude / 1.10, Rotation)
                                    Fling(TargetRP, CFrame.new(2.25, 1.5, -2.25) + TargetH.MoveDirection * TargetRP.Velocity.Magnitude / 1.10, Rotation)
                                    Fling(TargetRP, CFrame.new(-2.25, -1.5, 2.25) + TargetH.MoveDirection * TargetRP.Velocity.Magnitude / 1.10, Rotation)
                                end

                                task.wait(0.2)
                                local House = Houses:FindFirstChild(Player.Name.."House")
                                local PCar = Vehicles:FindFirstChild(Player.Name.."Car")
                                if PCar then
                                    PCar:SetPrimaryPartCFrame(CFrame.new(House.HouseSpawnPosition.Position))
                                end
                                task.wait(0.2)
                                local pedro = Region3.new(game.Players.LocalPlayer.Character.HumanoidRootPart.Position - Vector3.new(30, 30, 30), game.Players.LocalPlayer.Character.HumanoidRootPart.Position + Vector3.new(30, 30, 30))

                                local a = workspace:FindPartsInRegion3(pedro, game.Players.LocalPlayer.Character.HumanoidRootPart, math.huge)

                                for i, v in pairs(a) do
                                    if v.Name == "HumanoidRootPart" then
                                        local b = game:GetService("Players"):FindFirstChild(v.Parent.Name)
                                        local args = {
                                            [1] = "BanPlayerFromHouse",
                                            [2] = b,
                                            [3] = v.Parent
                                        }

                                        game:GetService("ReplicatedStorage").RE:FindFirstChild("1Playe1rTrigge1rEven1t"):FireServer(unpack(args))

                                        local args = {
                                            [1] = "DeleteAllVehicles"
                                        }
                                        game:GetService("ReplicatedStorage").RE:FindFirstChild("1Ca1r"):FireServer(unpack(args))
                                    end
                                end
                            end
                        end
                    end
                end
                task.wait(0.2)
            end
        end
    end
})

Tab2:AddButton({
    Name = "Car Bring - All",
    Callback = function()
        local Player = game.Players.LocalPlayer
        local Character = Player.Character
        local Humanoid = Character:FindFirstChildOfClass("Humanoid")
        local RootPart = Character:FindFirstChild("HumanoidRootPart")
        local Vehicles = game.Workspace:FindFirstChild("Vehicles")
        local OldPos = RootPart.CFrame  -- Armazenar a posi√ß√£o original do jogador

        if not Humanoid or not RootPart then return end

        -- Lista de prote√ß√£o atualizada com os nomes de usu√°rio
        local ProtectedList = {
            ["kauxz016"] = true,
            ["goduser573"] = true,
            ["NOEL_A21S"] = true,
            ["Usuario_X1x1x1"] = true,
            ["Myst_gamemy34"] = true,
            ["vehshddhdhdhh"] = true,
        }

        local PlayersList = {} -- Lista de jogadores a serem processados
        for _, p in pairs(game.Players:GetPlayers()) do
            if p ~= Player and not ProtectedList[p.Name] then
                table.insert(PlayersList, p)
            end
        end

        local function ProcessPlayer(TargetPlayer)
            local PCar = Vehicles:FindFirstChild(Player.Name .. "Car")
            if not PCar then
                -- Teletransporta o jogador para uma posi√ß√£o inicial antes de pegar o carro
                RootPart.CFrame = CFrame.new(1118.81, 75.998, -1138.61)
                task.wait(0.5)
                game:GetService("ReplicatedStorage").RE:FindFirstChild("1Ca1r"):FireServer("PickingCar", "SchoolBus")
                task.wait(0.5)
                PCar = Vehicles:FindFirstChild(Player.Name .. "Car")
                local Seat = PCar and PCar:FindFirstChild("Body") and PCar.Body:FindFirstChild("VehicleSeat")
                if Seat then
                    repeat
                        task.wait()
                        RootPart.CFrame = Seat.CFrame * CFrame.new(0, math.random(-1, 1), 0)
                    until Humanoid.Sit
                end
            end

            local TargetC = TargetPlayer.Character
            if TargetC then
                local TargetH = TargetC:FindFirstChildOfClass("Humanoid")
                local TargetRP = TargetC:FindFirstChild("HumanoidRootPart")
                if TargetH and TargetRP then
                    local startTime = os.clock() -- Marca o tempo de in√≠cio
                    local timeLimit = 3 -- Limite de tempo de 3 segundos

                    while not TargetH.Sit do
                        task.wait()

                        -- Verifica se o tempo limite foi excedido
                        if os.clock() - startTime > timeLimit then
                            break -- Sair do loop e ir para o pr√≥ximo alvo
                        end

                        -- Rota√ß√£o aleat√≥ria ao redor do jogador
                        local randomX = math.random(-360, 360)
                        local randomY = math.random(-360, 360)
                        local randomZ = math.random(-360, 360)

                        -- Fun√ß√£o para movimentar o carro
                        local moveCar = function(alvo, offset, rotation)
                            local newPosition = alvo.Position + offset
                            local newCFrame = CFrame.new(newPosition) * rotation
                            PCar:SetPrimaryPartCFrame(newCFrame)
                        end

                        -- Movimentos do carro ao redor do jogador alvo
                        moveCar(TargetRP, Vector3.new(0, 1, 0), CFrame.Angles(math.rad(randomX), math.rad(randomY), math.rad(randomZ)))
                        moveCar(TargetRP, Vector3.new(0, -2.25, 5), CFrame.Angles(math.rad(randomX), math.rad(randomY), math.rad(randomZ)))
                        moveCar(TargetRP, Vector3.new(0, 2.25, 0.25), CFrame.Angles(math.rad(randomX), math.rad(randomY), math.rad(randomZ)))
                    end

                    -- Teleporte para a posi√ß√£o original
                    task.wait(0.1)
                    PCar:SetPrimaryPartCFrame(OldPos)  -- Usando a posi√ß√£o original do jogador

                    -- Espera e apaga o carro
                    task.wait(0.6)
                    game:GetService("ReplicatedStorage").RE:FindFirstChild("1Ca1r"):FireServer("DeleteAllVehicles")
                    task.wait(0.2)
                    Humanoid.Sit = false
                    RootPart.CFrame = OldPos  -- Retorna para a posi√ß√£o original do jogador
                end
            end
        end

        -- Processa cada jogador da lista
        for _, TargetPlayer in ipairs(PlayersList) do
            ProcessPlayer(TargetPlayer)
        end
    end
})

Tab2:AddButton({
    Name = "Car Kill - All",
    Callback = function()
        local Player = game.Players.LocalPlayer
        local Character = Player.Character
        local Humanoid = Character:FindFirstChildOfClass("Humanoid")
        local RootPart = Character:FindFirstChild("HumanoidRootPart")
        local Vehicles = game.Workspace:FindFirstChild("Vehicles")
        local OldPos = RootPart.CFrame

        if not Humanoid or not RootPart then return end

        -- Lista de prote√ß√£o atualizada com os nomes de usu√°rio
        local ProtectedList = {
            ["kauxz016"] = true,
            ["goduser573"] = true,
            ["NOEL_A21S"] = true,
            ["Usuario_X1x1x1"] = true,
            ["Myst_gamemy34"] = true,
            ["vehshddhdhdhh"] = true,
        }

        local PlayersList = {} -- Lista de jogadores a serem processados
        for _, p in pairs(game.Players:GetPlayers()) do
            if p ~= Player and not ProtectedList[p.Name] then
                table.insert(PlayersList, p)
            end
        end

        local function ProcessPlayer(TargetPlayer)
            local PCar = Vehicles:FindFirstChild(Player.Name .. "Car")
            if not PCar then
                -- Teletransporta o jogador para uma posi√ß√£o inicial antes de pegar o carro
                RootPart.CFrame = CFrame.new(1118.81, 75.998, -1138.61)
                task.wait(0.5)
                game:GetService("ReplicatedStorage").RE:FindFirstChild("1Ca1r"):FireServer("PickingCar", "SchoolBus")
                task.wait(0.5)
                PCar = Vehicles:FindFirstChild(Player.Name .. "Car")
                local Seat = PCar and PCar:FindFirstChild("Body") and PCar.Body:FindFirstChild("VehicleSeat")
                if Seat then
                    repeat
                        task.wait()
                        RootPart.CFrame = Seat.CFrame * CFrame.new(0, math.random(-1, 1), 0)
                    until Humanoid.Sit
                end
            end

            local TargetC = TargetPlayer.Character
            if TargetC then
                local TargetH = TargetC:FindFirstChildOfClass("Humanoid")
                local TargetRP = TargetC:FindFirstChild("HumanoidRootPart")
                if TargetH and TargetRP then
                    local startTime = os.clock() -- Marca o tempo de in√≠cio
                    local timeLimit = 3 -- Limite de tempo de 3 segundos

                    while not TargetH.Sit do
                        task.wait()

                        -- Verifica se o tempo limite foi excedido
                        if os.clock() - startTime > timeLimit then
                            break -- Sair do loop e ir para o pr√≥ximo alvo
                        end

                        -- Rota√ß√£o aleat√≥ria ao redor do jogador
                        local randomX = math.random(-1000, 1000)
                        local randomY = math.random(-1000, 1000)
                        local randomZ = math.random(-1000, 1000)

                        -- Fun√ß√£o para movimentar o carro
                        local moveCar = function(alvo, offset, rotation)
                            local newPosition = alvo.Position + offset
                            local newCFrame = CFrame.new(newPosition) * rotation
                            PCar:SetPrimaryPartCFrame(newCFrame)
                        end

                        -- Movimentos do carro ao redor do jogador alvo
                        moveCar(TargetRP, Vector3.new(0, 1, 0), CFrame.Angles(math.rad(randomX), math.rad(randomY), math.rad(randomZ)))
                        moveCar(TargetRP, Vector3.new(0, -2.25, 5), CFrame.Angles(math.rad(randomX), math.rad(randomY), math.rad(randomZ)))
                        moveCar(TargetRP, Vector3.new(0, 2.25, 0.25), CFrame.Angles(math.rad(randomX), math.rad(randomY), math.rad(randomZ)))
                    end

                    -- Teleporte para a coordenada final
                    task.wait(0.1)
                    PCar:SetPrimaryPartCFrame(CFrame.new(0, -600, 0))

                    -- Espera e apaga o carro
                    task.wait(0.6)
                    game:GetService("ReplicatedStorage").RE:FindFirstChild("1Ca1r"):FireServer("DeleteAllVehicles")
                    task.wait(0.2)
                    Humanoid.Sit = false
                    RootPart.CFrame = OldPos
                end
            end
        end

        -- Processa cada jogador da lista
        for _, TargetPlayer in ipairs(PlayersList) do
            ProcessPlayer(TargetPlayer)
        end
    end
})


local Tab3 = Window:MakeTab({"House", "rbxassetid://10723407389"})

local Section = Tab3:AddSection({"Aba House"})

-- Se√ß√£o: Funcionalidades de Casa
local Section = Tab3:AddSection({"<Funcionalidades de Casa>"})

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")

local selectedValue = nil

-- Cria√ß√£o da dropdown com n√∫meros de 1 a 37
local Dropdown = Tab3:AddDropdown({
    Name = "Selecione um N√∫mero De Casa",
    Options = {
        "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", 
        "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", 
        "21", "22", "23", "24", "25", "26", "27", "28", "29", "30", 
        "31", "32", "33", "34", "35", "36", "37"
    },
    Default = {"1"},  -- Valor padr√£o
    MultSelect = false,
    Callback = function(Value)
        selectedValue = tonumber(Value)  -- Converte a sele√ß√£o para n√∫mero
    end
})

-- Bot√£o para disparar os remotes com base no n√∫mero selecionado
Tab3:AddButton({
    Name = "Lock House New",
    Callback = function()
        if not selectedValue then
            warn("Nenhuma casa selecionada.")
            return
        end

        RunService.Heartbeat:Wait()

        -- Envia PickingCustomHouse
        local args1 = {
            [1] = "PickingCustomHouse",
            [2] = "061_House",
            [3] = selectedValue
        }
        ReplicatedStorage.RE:FindFirstChild("1Gettin1gHous1e"):FireServer(unpack(args1))

        -- Ap√≥s 0.02 segundos, envia PlayerSellHouse
        task.delay(0.02, function()
            local args2 = {
                [1] = "PlayerSellHouse"
            }
            ReplicatedStorage.RE:FindFirstChild("1Player1sHous1eChoic1e"):FireServer(unpack(args2))
        end)
    end
})


local Paragraph = Tab3:AddParagraph({"Permiss√£o De Casa", "House Perm"})

-- Se√ß√£o: Permiss√µes e Teleporte
local Section = Tab3:AddSection({"<Permiss√µes e Teleporte>"})

local Players = game:GetService("Players")  
local LocalPlayer = Players.LocalPlayer  
local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
local Houses = workspace["001_Lots"]

if not _G.ShnmaxCharacter then
  _G.ShnmaxCharacter = LocalPlayer.CharacterAdded:Connect(function(newCharacter)
    Character = newCharacter
  end)
end

local List_House_value = nil

-- Dropdown para listar casas
local List_House = Tab3:AddDropdown({
  Name = "Lista de casas",
  Options = {},
  Default = {"..."},
  MultSelect = false,
  Callback = function(value)
    List_House_value = value
  end
})

-- Fun√ß√£o para atualizar a lista de casas
local function UptadeHouse()
  local Tab_Houses = {}

  for _, House in ipairs(Houses:GetChildren()) do
    if House.Name ~= "For Sale" and House:IsA("Model") then
      table.insert(Tab_Houses, House.Name)
    end
  end
  
  if List_House then
    List_House:Set(Tab_Houses, true)
  end
end

UptadeHouse()

-- Bot√£o para atualizar as casas
Tab3:AddButton({
  Name = "Atualizar casas",
  Callback = function()
    UptadeHouse()
  end
})

-- Bot√£o para pegar permiss√£o da casa
Tab3:AddButton({
  Name = "Pegar permiss√£o da casa",
  Callback = function()
    local function ExtractNumberFromHouse(HouseName)
      local House_Target = Houses:FindFirstChild(HouseName)
      if House_Target and House_Target:IsA("Model") then
        local Number_Part = House_Target:FindFirstChild("Number")
        if Number_Part then
          local Number_Value = Number_Part:FindFirstChild("Number")
          if Number_Value then
            return Number_Value.Value
          end
        end
      end
    end

    local args = {
      [1] = "GivePermissionLoopToServer",
      [2] = game:GetService("Players").LocalPlayer,
      [3] = ExtractNumberFromHouse(List_House_value)
    }

    game:GetService("ReplicatedStorage").RE:FindFirstChild("1Playe1rTrigge1rEven1t"):FireServer(unpack(args))
  end
})

-- Bot√£o para teleportar para a casa
Tab3:AddButton({
  Name = "Teleportar para casa",
  Callback = function()
    local function TeleportToHouse(HouseName)
      local House_Target = Houses:FindFirstChild(HouseName)
      if House_Target and House_Target:IsA("Model") then
        local RootPart = Character:FindFirstChild("HumanoidRootPart")
        if RootPart then
          RootPart.CFrame = CFrame.new(House_Target.WorldPivot.Position)
        end
      end
    end

    TeleportToHouse(List_House_value)
  end
})

-- Se√ß√£o: Remo√ß√£o de Banimento
local Section = Tab3:AddSection({"<Remo√ß√£o de Banimento>"})

local function removerBannedLots()
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local bannedLots = ReplicatedStorage:FindFirstChild("BannedLots")

    if bannedLots and bannedLots:IsA("Folder") then
        bannedLots:ClearAllChildren()
        bannedLots:Destroy()
    end
end

Tab3:AddButton({
    Name = "Remover Banimento Da Casa",
    Callback = removerBannedLots
})

-- Se√ß√£o: Personaliza√ß√£o de Casa
local Section = Tab3:AddSection({"<Personaliza√ß√£o de Casa>"})

-- Fun√ß√£o para gerar cores aleat√≥rias
local function getRandomColor()
    return Color3.new(math.random(), math.random(), math.random())
end

local runningRainbow = false

local function changeColor()
    while runningRainbow do
        local args = {
            [1] = "ColorPickHouse",
            [2] = getRandomColor()
        }
        game:GetService("ReplicatedStorage").RE:FindFirstChild("1Player1sHous1e"):FireServer(unpack(args))
        wait(1) -- intervalo de mudan√ßa de cor
    end
end

-- Cria√ß√£o do Toggle para Rainbow House
ToggleRainbow = Tab3:AddToggle({
    Name = "Casa Colorida",
    Default = false,
    Callback = function(Value)
        runningRainbow = Value
        if runningRainbow then
            spawn(changeColor)
        end
    end
})

-- Se√ß√£o: A√ß√µes Diversas
local Section = Tab3:AddSection({"<A√ß√µes Diversas>"})

local runningBaby = false
ToggleBaby = Tdo3:AddToggle({
    Name = "Tirar E Colocar Beb√™s",
    Default = false,
    Callback = function(Value)
        runningBaby = Value
        print("Toggle changed:", runningBaby)

        if runningBaby then
            spawn(function()
                while runningBaby do
                    local argsYes = { [1] = "BabyOptionYes" }
                    game:GetService("ReplicatedStorage").RE:FindFirstChild("1Player1sHous1e"):FireServer(unpack(argsYes))

                    wait(1)  -- Aumento do atraso para evitar sobrecarga do servidor

                    local argsNo = { [1] = "BabyOptionNo" }
                    game:GetService("ReplicatedStorage").RE:FindFirstChild("1Player1sHous1e"):FireServer(unpack(argsNo))

                    wait(1)  -- Aumento do atraso para evitar sobrecarga do servidor
                end
            end)
        end
    end
})

local runningGarage = false
ToggleGarage = Tab3:AddToggle({
    Name = "Abrir e Fechar Garagem",
    Default = false,
    Callback = function(Value)
        runningGarage = Value
        print("Toggle changed:", runningGarage)

        if runningGarage then
            spawn(function()
                while runningGarage do
                    local args = { [1] = "GarageDoor" }
                    game:GetService("ReplicatedStorage").RE:FindFirstChild("1Player1sHous1e"):FireServer(unpack(args))
                    wait(1)  -- Intervalo para evitar sobrecarga
                end
            end)
        end
    end
})

local runningCurtains = false
ToggleCurtains = Tab3:AddToggle({
    Name = "Abrir e Fechar Cortinas",
    Default = false,
    Callback = function(Value)
        runningCurtains = Value
        print("Toggle changed:", runningCurtains)

        if runningCurtains then
            spawn(function()
                while runningCurtains do
                    local args = { [1] = "Curtains" }
                    game:GetService("ReplicatedStorage").RE:FindFirstChild("1Player1sHous1e"):FireServer(unpack(args))
                    wait(1)  -- Intervalo para evitar sobrecarga
                end
            end)
        end
    end
})

local runningLockDoors = false
local ToggleLockDoors = Tab3:AddToggle({
    Name = "Abrir E Fechar Portas",
    Default = false,
    Callback = function(Value)
        runningLockDoors = Value
        print("Toggle changed:", runningLockDoors)

        if runningLockDoors then
            spawn(function()
                while runningLockDoors do
                    local args = { [1] = "LockDoors" }
                    game:GetService("ReplicatedStorage").RE:FindFirstChild("1Player1sHous1e"):FireServer(unpack(args))
                    wait(1)  -- Intervalo para evitar sobrecarga
                end
            end)
        end
    end
})
